{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"micropython-appengine # A MicroPython app engine. This module works under MicroPython and it is tested with MicroPython V1.19.1. Installation # >>> import upip >>> upip . install ( 'micropython-appengine' ) Alternatively just copy appengine.py to the MicroPython device. Simple Demo # Hardware # ESP32 DevKitC SSD1306 128x64 OLED with I2C interface SCL on pin 16 SDA on pin 17 Touchpads BACK on pin 32 UP on pin 15 ENTER on pin 4 LEFT on pin 27 DOWN on pin 12 RIGHT on pin 2 Firmware # MicroPython V1.19.1. Software # \"\"\"An appengine simple demo. - Author: Quan Lin - License: MIT \"\"\" from math import ceil from machine import Pin , I2C , TouchPad from framebuf import FrameBuffer , MONO_VLSB from ssd1306 import SSD1306_I2C from appengine import InputDevice , Screen , Sprite , Manager class GameKeyBoard ( InputDevice ): NUM_OF_KEYS = 6 BACK , UP , ENTER , LEFT , DOWN , RIGHT = tuple ( range ( NUM_OF_KEYS )) PIN_BACK = 32 PIN_UP = 15 PIN_ENTER = 4 PIN_LEFT = 27 PIN_DOWN = 12 PIN_RIGHT = 2 THRE_BACK = 690 THRE_UP = 620 THRE_ENTER = 570 THRE_LEFT = 570 THRE_DOWN = 590 THRE_RIGHT = 520 def __init__ ( self ): super () . __init__ () self . keys = [ TouchPad ( Pin ( self . PIN_BACK )), TouchPad ( Pin ( self . PIN_UP )), TouchPad ( Pin ( self . PIN_ENTER )), TouchPad ( Pin ( self . PIN_LEFT )), TouchPad ( Pin ( self . PIN_DOWN )), TouchPad ( Pin ( self . PIN_RIGHT )), ] self . _thresholds = [ self . THRE_BACK , self . THRE_UP , self . THRE_ENTER , self . THRE_LEFT , self . THRE_DOWN , self . THRE_RIGHT , ] self . keys_all = set ( range ( self . NUM_OF_KEYS )) self . keys_on = set () self . keys_off = self . keys_all - self . keys_on self . keys_pressed = set () self . keys_released = set () def update ( self ): old_keys_on = self . keys_on old_keys_off = self . keys_off self . keys_on = set () for i in range ( len ( self . keys )): if self . keys [ i ] . read () < self . _thresholds [ i ]: self . keys_on . add ( i ) self . keys_off = self . keys_all - self . keys_on self . keys_pressed = self . keys_on - old_keys_on self . keys_released = self . keys_off - old_keys_off class GameScreen ( Screen ): WIDTH = 128 HEIGHT = 64 I2C_SCL = 16 I2C_SDA = 17 def __init__ ( self ): super () . __init__ () i2c = I2C ( 1 , scl = Pin ( self . I2C_SCL ), sda = Pin ( self . I2C_SDA )) self . display = SSD1306_I2C ( self . WIDTH , self . HEIGHT , i2c ) self . w = self . WIDTH self . h = self . HEIGHT def update ( self ): self . display . show () class Player ( Sprite ): WIDTH = 8 HEIGHT = 8 FB_ALIVE0 = FrameBuffer ( bytearray ( WIDTH * ceil ( HEIGHT / 8 )), WIDTH , HEIGHT , MONO_VLSB , ) FB_ALIVE0 . fill_rect ( 0 , 0 , WIDTH , HEIGHT , 1 ) FB_ALIVE1 = FrameBuffer ( bytearray ( WIDTH * ceil ( HEIGHT / 8 )), WIDTH , HEIGHT , MONO_VLSB , ) FB_ALIVE1 . fill_rect ( WIDTH // 4 , HEIGHT // 4 , WIDTH // 2 , HEIGHT // 2 , 1 ) def __init__ ( self ): super () . __init__ () self . x = GameScreen . WIDTH // 2 self . y = GameScreen . HEIGHT // 2 self . w = self . WIDTH self . h = self . HEIGHT self . imgs = [ self . FB_ALIVE0 , self . FB_ALIVE1 , ] self . setup_animation ( 0 , 2 , 5 ) self . name = \"player\" def update ( self ): keyboard = self . manager . input_device if GameKeyBoard . UP in keyboard . keys_on : self . vy = - 3 elif GameKeyBoard . DOWN in keyboard . keys_on : self . vy = 3 else : self . vy = 0 if GameKeyBoard . LEFT in keyboard . keys_on : self . vx = - 3 elif GameKeyBoard . RIGHT in keyboard . keys_on : self . vx = 3 else : self . vx = 0 self . clamp_position ( 0 , 0 , GameScreen . HEIGHT , GameScreen . WIDTH ) if GameKeyBoard . ENTER in keyboard . keys_pressed : print ( \"`Enter` is pressed.\" ) class OverlayText ( Sprite ): WIDTH = 128 HEIGHT = 8 FB = FrameBuffer ( bytearray ( WIDTH * ceil ( HEIGHT / 8 )), WIDTH , HEIGHT , MONO_VLSB , ) def __init__ ( self ): super () . __init__ () self . x = 0 self . y = 0 self . w = self . WIDTH self . h = self . HEIGHT self . imgs = [ self . FB ] self . colourkey = 0 self . is_overlay = True self . set_layer ( 255 ) def update ( self ): self . FB . fill ( 0 ) fps_objs_text = \"FPS: {:3d} OBJs: {:3d} \" . format ( int ( self . manager . actual_fps + 0.5 ), len ( self . manager . get_sprites ()), ) self . FB . text ( fps_objs_text , 0 , 0 ) class GameManager ( Manager ): def __init__ ( self ): super () . __init__ () self . input_device = GameKeyBoard () self . screen = GameScreen () self . add_sprite ( Player ()) self . add_sprite ( OverlayText ()) def update ( self ): if GameKeyBoard . BACK in self . input_device . keys_released : print ( \"`Back` is released. Exiting...\" ) self . exit () return if __name__ == \"__main__\" : GameManager () . run ()","title":"Home"},{"location":"#micropython-appengine","text":"A MicroPython app engine. This module works under MicroPython and it is tested with MicroPython V1.19.1.","title":"micropython-appengine"},{"location":"#installation","text":">>> import upip >>> upip . install ( 'micropython-appengine' ) Alternatively just copy appengine.py to the MicroPython device.","title":"Installation"},{"location":"#simple-demo","text":"","title":"Simple Demo"},{"location":"#hardware","text":"ESP32 DevKitC SSD1306 128x64 OLED with I2C interface SCL on pin 16 SDA on pin 17 Touchpads BACK on pin 32 UP on pin 15 ENTER on pin 4 LEFT on pin 27 DOWN on pin 12 RIGHT on pin 2","title":"Hardware"},{"location":"#firmware","text":"MicroPython V1.19.1.","title":"Firmware"},{"location":"#software","text":"\"\"\"An appengine simple demo. - Author: Quan Lin - License: MIT \"\"\" from math import ceil from machine import Pin , I2C , TouchPad from framebuf import FrameBuffer , MONO_VLSB from ssd1306 import SSD1306_I2C from appengine import InputDevice , Screen , Sprite , Manager class GameKeyBoard ( InputDevice ): NUM_OF_KEYS = 6 BACK , UP , ENTER , LEFT , DOWN , RIGHT = tuple ( range ( NUM_OF_KEYS )) PIN_BACK = 32 PIN_UP = 15 PIN_ENTER = 4 PIN_LEFT = 27 PIN_DOWN = 12 PIN_RIGHT = 2 THRE_BACK = 690 THRE_UP = 620 THRE_ENTER = 570 THRE_LEFT = 570 THRE_DOWN = 590 THRE_RIGHT = 520 def __init__ ( self ): super () . __init__ () self . keys = [ TouchPad ( Pin ( self . PIN_BACK )), TouchPad ( Pin ( self . PIN_UP )), TouchPad ( Pin ( self . PIN_ENTER )), TouchPad ( Pin ( self . PIN_LEFT )), TouchPad ( Pin ( self . PIN_DOWN )), TouchPad ( Pin ( self . PIN_RIGHT )), ] self . _thresholds = [ self . THRE_BACK , self . THRE_UP , self . THRE_ENTER , self . THRE_LEFT , self . THRE_DOWN , self . THRE_RIGHT , ] self . keys_all = set ( range ( self . NUM_OF_KEYS )) self . keys_on = set () self . keys_off = self . keys_all - self . keys_on self . keys_pressed = set () self . keys_released = set () def update ( self ): old_keys_on = self . keys_on old_keys_off = self . keys_off self . keys_on = set () for i in range ( len ( self . keys )): if self . keys [ i ] . read () < self . _thresholds [ i ]: self . keys_on . add ( i ) self . keys_off = self . keys_all - self . keys_on self . keys_pressed = self . keys_on - old_keys_on self . keys_released = self . keys_off - old_keys_off class GameScreen ( Screen ): WIDTH = 128 HEIGHT = 64 I2C_SCL = 16 I2C_SDA = 17 def __init__ ( self ): super () . __init__ () i2c = I2C ( 1 , scl = Pin ( self . I2C_SCL ), sda = Pin ( self . I2C_SDA )) self . display = SSD1306_I2C ( self . WIDTH , self . HEIGHT , i2c ) self . w = self . WIDTH self . h = self . HEIGHT def update ( self ): self . display . show () class Player ( Sprite ): WIDTH = 8 HEIGHT = 8 FB_ALIVE0 = FrameBuffer ( bytearray ( WIDTH * ceil ( HEIGHT / 8 )), WIDTH , HEIGHT , MONO_VLSB , ) FB_ALIVE0 . fill_rect ( 0 , 0 , WIDTH , HEIGHT , 1 ) FB_ALIVE1 = FrameBuffer ( bytearray ( WIDTH * ceil ( HEIGHT / 8 )), WIDTH , HEIGHT , MONO_VLSB , ) FB_ALIVE1 . fill_rect ( WIDTH // 4 , HEIGHT // 4 , WIDTH // 2 , HEIGHT // 2 , 1 ) def __init__ ( self ): super () . __init__ () self . x = GameScreen . WIDTH // 2 self . y = GameScreen . HEIGHT // 2 self . w = self . WIDTH self . h = self . HEIGHT self . imgs = [ self . FB_ALIVE0 , self . FB_ALIVE1 , ] self . setup_animation ( 0 , 2 , 5 ) self . name = \"player\" def update ( self ): keyboard = self . manager . input_device if GameKeyBoard . UP in keyboard . keys_on : self . vy = - 3 elif GameKeyBoard . DOWN in keyboard . keys_on : self . vy = 3 else : self . vy = 0 if GameKeyBoard . LEFT in keyboard . keys_on : self . vx = - 3 elif GameKeyBoard . RIGHT in keyboard . keys_on : self . vx = 3 else : self . vx = 0 self . clamp_position ( 0 , 0 , GameScreen . HEIGHT , GameScreen . WIDTH ) if GameKeyBoard . ENTER in keyboard . keys_pressed : print ( \"`Enter` is pressed.\" ) class OverlayText ( Sprite ): WIDTH = 128 HEIGHT = 8 FB = FrameBuffer ( bytearray ( WIDTH * ceil ( HEIGHT / 8 )), WIDTH , HEIGHT , MONO_VLSB , ) def __init__ ( self ): super () . __init__ () self . x = 0 self . y = 0 self . w = self . WIDTH self . h = self . HEIGHT self . imgs = [ self . FB ] self . colourkey = 0 self . is_overlay = True self . set_layer ( 255 ) def update ( self ): self . FB . fill ( 0 ) fps_objs_text = \"FPS: {:3d} OBJs: {:3d} \" . format ( int ( self . manager . actual_fps + 0.5 ), len ( self . manager . get_sprites ()), ) self . FB . text ( fps_objs_text , 0 , 0 ) class GameManager ( Manager ): def __init__ ( self ): super () . __init__ () self . input_device = GameKeyBoard () self . screen = GameScreen () self . add_sprite ( Player ()) self . add_sprite ( OverlayText ()) def update ( self ): if GameKeyBoard . BACK in self . input_device . keys_released : print ( \"`Back` is released. Exiting...\" ) self . exit () return if __name__ == \"__main__\" : GameManager () . run ()","title":"Software"},{"location":"api/","text":"API Reference # A MicroPython app engine. Author: Quan Lin License: MIT AppEngineException # Bases: Exception A class for appengine exception. InputDevice () # A class for the input device. Note This class needs to be subclassed to be useful. Override __init__() to initialise the input device. Override update() to implement the logic of the input device. update () # This method should implement the logic of the input device. It is called before every frame by the manager. Raises: Type Description AppEngineException An error occurred when this class is not subclassed. Note This method must be overridden by a subclass. Manager () # A class for app manager. Attributes: Name Type Description DEFAULT_TARGET_FPS int 20 , default target FPS (frames per second). input_device InputDevice The input device. screen Screen The screen. sprite_list list The list holding all the available sprites. target_fps float The target FPS. actual_fps float The actual FPS. running bool The flag indicating the app is running or not. Note This class needs to be subclassed to be useful. Override __init__() to initialise the manager. Override update() to implement the logic of the manager. add_sprite ( sprite ) # Add a sprite to the manager. Parameters: Name Type Description Default sprite Sprite The sprite to be added to the manager. required arun () async # Run the app asynchronously with uasyncio . exit () # Exit the app. get_sprites ( cls = Sprite , name = None ) # Get a filtered list of sprites. Parameters: Name Type Description Default cls type The class of the sprites that should be returned. Sprite name str The name of the sprites that should be returned. None Returns: Type Description list [ Sprite , ...] A list of selected sprites. kill_sprites ( cls = Sprite , name = None ) # Kill a filtered list of sprites. Parameters: Name Type Description Default cls type The class of the sprites that should be killed. Sprite name str The name of the sprites that should be killed. None run () # Run the app. update () # This method may implement the logic of the manager. It is called before every frame. A very simple app may not override it. Screen () # A class for the screen. Attributes: Name Type Description display FrameBuffer A display object whose class is a subclass of FrameBuffer . For example, an SSD1306 driver object. w int The width of the screen in pixel. h int The height of the screen in pixel. camera_target Sprite If not None , the screen camera will follow this sprite. The center of this sprite will be placed at the center of the screen. Note This class needs to be subclassed to be useful. Override __init__() to initialise the screen. Override update() to show the content of the screen from its buffer. blit ( sprite ) # Blit the sprite at its position in the screen. It is called before every frame for each sprite added to the manager. Parameters: Name Type Description Default sprite Sprite A sprite to be placed in the screen at its position. required clear () # Clear the screen buffer and update it. flip () # Update the screen and clear the screen buffer. It is called before every frame by the manager. update () # This method should show the content of the screen from its buffer. For example, the show() method of an SSD1306 driver can be called here. Raises: Type Description AppEngineException An error occurred when this class is not subclassed. Note This method must be overridden by a subclass. Sprite () # A class for app sprites. Attributes: Name Type Description UP int 1 , direction up. LEFT int 2 , direction left. DOWN int 3 , direction down. RIGHT int 4 , direction right. x float The x position of the sprite. y float The y position of the sprite. w int The width of the sprite in pixel. h int The height of the sprite in pixel. vx float The x velocity of the sprite. vy float The y velocity of the sprite. imgs list The list of images to represent the sprite. A sequence of images can make animation. img_idx int The index of the image to be shown. img_fpstep_counter int Frames per step counter for animation. colourkey int Transparent colour, -1 means no transparent colour. is_overlay bool If True, the sprite is ignored by screen camera. manager Manager The manager of the app. When a sprite is added to the manager, this attribute is set automatically. name str The name of the sprite. killed bool If True, the sprite will be removed by the manager. Note This class needs to be subclassed to be useful. Override __init__() to initialise the sprite. Override update() to implement the logic of the sprite. check_collision ( other ) # Check collision with the other sprite. This is a simple example of collision detection. It can be overridden with other implementation. When there is no collision detected, it returns None . When collision is detected, a 2-tuple is returned. The first element indicates where the collision happened. It could be Sprite.UP , Sprite.LEFT , Sprite.DOWN or Sprite.RIGHT . The second element indicates how deep the collision is in pixel. Parameters: Name Type Description Default other Sprite The other sprite to check collision with. required Returns: Type Description tuple [ int , int ] A 2-tuple or None . clamp_position ( up = None , left = None , down = None , right = None ) # Clamp the position of the sprite. This method clamps the position of the sprite. The size of the sprite is taken into account. The up and left limits are inclusive. The down and right limits are exclusive. When there is conflict in left and right limits, the left limit overrides. When there is conflict in up and down limits, the up limit overrides. Parameters: Name Type Description Default up float Up limit of the up side of the sprite. None left float Left limit of the left side of the sprite. None down float Down limit of the down side of the sprite. None right float Right limit of the right side of the sprite. None clamp_velocity ( vx_min = None , vx_max = None , vy_min = None , vy_max = None ) # Clamp the velocity of the sprite. Parameters: Name Type Description Default vx_min float Min limit of x velocity of the sprite. None vx_max float Max limit of x velocity of the sprite. None vy_min float Min limit of y velocity of the sprite. None vy_max float Max limit of y velocity of the sprite. None get_layer () # Get the layer in which the sprite is located. A larger number means the sprite is in a more upper layer. Returns: Type Description int The layer in which the sprite is located. kill () # Kill the sprite, so it will be removed by the manager. kill_after_n_frames ( num ) # Kill the sprite in a delayed manner. Parameters: Name Type Description Default num int The number of frames after which the sprite will be killed. For example, given 20 FPS, setting 40 will kill the sprite after 2 seconds. required set_layer ( layer ) # Set the layer in which the sprite is located. A larger number means the sprite is in a more upper layer. Parameters: Name Type Description Default layer int The layer in which the sprite is located. required setup_animation ( start , length , fpstep ) # Setup animation for the sprite. Parameters: Name Type Description Default start int The start index of the images for animation. required length int The length of the images for animation. required fpstep int Frames per step for animation speed. required update () # This method may implement the logic of the sprite. It is called before every frame. A passive sprite may not override it.","title":"API Reference"},{"location":"api/#api-reference","text":"A MicroPython app engine. Author: Quan Lin License: MIT","title":"API Reference"},{"location":"api/#micropython-appengine.AppEngineException","text":"Bases: Exception A class for appengine exception.","title":"AppEngineException"},{"location":"api/#micropython-appengine.InputDevice","text":"A class for the input device. Note This class needs to be subclassed to be useful. Override __init__() to initialise the input device. Override update() to implement the logic of the input device.","title":"InputDevice"},{"location":"api/#micropython-appengine.InputDevice.update","text":"This method should implement the logic of the input device. It is called before every frame by the manager. Raises: Type Description AppEngineException An error occurred when this class is not subclassed. Note This method must be overridden by a subclass.","title":"update()"},{"location":"api/#micropython-appengine.Manager","text":"A class for app manager. Attributes: Name Type Description DEFAULT_TARGET_FPS int 20 , default target FPS (frames per second). input_device InputDevice The input device. screen Screen The screen. sprite_list list The list holding all the available sprites. target_fps float The target FPS. actual_fps float The actual FPS. running bool The flag indicating the app is running or not. Note This class needs to be subclassed to be useful. Override __init__() to initialise the manager. Override update() to implement the logic of the manager.","title":"Manager"},{"location":"api/#micropython-appengine.Manager.add_sprite","text":"Add a sprite to the manager. Parameters: Name Type Description Default sprite Sprite The sprite to be added to the manager. required","title":"add_sprite()"},{"location":"api/#micropython-appengine.Manager.arun","text":"Run the app asynchronously with uasyncio .","title":"arun()"},{"location":"api/#micropython-appengine.Manager.exit","text":"Exit the app.","title":"exit()"},{"location":"api/#micropython-appengine.Manager.get_sprites","text":"Get a filtered list of sprites. Parameters: Name Type Description Default cls type The class of the sprites that should be returned. Sprite name str The name of the sprites that should be returned. None Returns: Type Description list [ Sprite , ...] A list of selected sprites.","title":"get_sprites()"},{"location":"api/#micropython-appengine.Manager.kill_sprites","text":"Kill a filtered list of sprites. Parameters: Name Type Description Default cls type The class of the sprites that should be killed. Sprite name str The name of the sprites that should be killed. None","title":"kill_sprites()"},{"location":"api/#micropython-appengine.Manager.run","text":"Run the app.","title":"run()"},{"location":"api/#micropython-appengine.Manager.update","text":"This method may implement the logic of the manager. It is called before every frame. A very simple app may not override it.","title":"update()"},{"location":"api/#micropython-appengine.Screen","text":"A class for the screen. Attributes: Name Type Description display FrameBuffer A display object whose class is a subclass of FrameBuffer . For example, an SSD1306 driver object. w int The width of the screen in pixel. h int The height of the screen in pixel. camera_target Sprite If not None , the screen camera will follow this sprite. The center of this sprite will be placed at the center of the screen. Note This class needs to be subclassed to be useful. Override __init__() to initialise the screen. Override update() to show the content of the screen from its buffer.","title":"Screen"},{"location":"api/#micropython-appengine.Screen.blit","text":"Blit the sprite at its position in the screen. It is called before every frame for each sprite added to the manager. Parameters: Name Type Description Default sprite Sprite A sprite to be placed in the screen at its position. required","title":"blit()"},{"location":"api/#micropython-appengine.Screen.clear","text":"Clear the screen buffer and update it.","title":"clear()"},{"location":"api/#micropython-appengine.Screen.flip","text":"Update the screen and clear the screen buffer. It is called before every frame by the manager.","title":"flip()"},{"location":"api/#micropython-appengine.Screen.update","text":"This method should show the content of the screen from its buffer. For example, the show() method of an SSD1306 driver can be called here. Raises: Type Description AppEngineException An error occurred when this class is not subclassed. Note This method must be overridden by a subclass.","title":"update()"},{"location":"api/#micropython-appengine.Sprite","text":"A class for app sprites. Attributes: Name Type Description UP int 1 , direction up. LEFT int 2 , direction left. DOWN int 3 , direction down. RIGHT int 4 , direction right. x float The x position of the sprite. y float The y position of the sprite. w int The width of the sprite in pixel. h int The height of the sprite in pixel. vx float The x velocity of the sprite. vy float The y velocity of the sprite. imgs list The list of images to represent the sprite. A sequence of images can make animation. img_idx int The index of the image to be shown. img_fpstep_counter int Frames per step counter for animation. colourkey int Transparent colour, -1 means no transparent colour. is_overlay bool If True, the sprite is ignored by screen camera. manager Manager The manager of the app. When a sprite is added to the manager, this attribute is set automatically. name str The name of the sprite. killed bool If True, the sprite will be removed by the manager. Note This class needs to be subclassed to be useful. Override __init__() to initialise the sprite. Override update() to implement the logic of the sprite.","title":"Sprite"},{"location":"api/#micropython-appengine.Sprite.check_collision","text":"Check collision with the other sprite. This is a simple example of collision detection. It can be overridden with other implementation. When there is no collision detected, it returns None . When collision is detected, a 2-tuple is returned. The first element indicates where the collision happened. It could be Sprite.UP , Sprite.LEFT , Sprite.DOWN or Sprite.RIGHT . The second element indicates how deep the collision is in pixel. Parameters: Name Type Description Default other Sprite The other sprite to check collision with. required Returns: Type Description tuple [ int , int ] A 2-tuple or None .","title":"check_collision()"},{"location":"api/#micropython-appengine.Sprite.clamp_position","text":"Clamp the position of the sprite. This method clamps the position of the sprite. The size of the sprite is taken into account. The up and left limits are inclusive. The down and right limits are exclusive. When there is conflict in left and right limits, the left limit overrides. When there is conflict in up and down limits, the up limit overrides. Parameters: Name Type Description Default up float Up limit of the up side of the sprite. None left float Left limit of the left side of the sprite. None down float Down limit of the down side of the sprite. None right float Right limit of the right side of the sprite. None","title":"clamp_position()"},{"location":"api/#micropython-appengine.Sprite.clamp_velocity","text":"Clamp the velocity of the sprite. Parameters: Name Type Description Default vx_min float Min limit of x velocity of the sprite. None vx_max float Max limit of x velocity of the sprite. None vy_min float Min limit of y velocity of the sprite. None vy_max float Max limit of y velocity of the sprite. None","title":"clamp_velocity()"},{"location":"api/#micropython-appengine.Sprite.get_layer","text":"Get the layer in which the sprite is located. A larger number means the sprite is in a more upper layer. Returns: Type Description int The layer in which the sprite is located.","title":"get_layer()"},{"location":"api/#micropython-appengine.Sprite.kill","text":"Kill the sprite, so it will be removed by the manager.","title":"kill()"},{"location":"api/#micropython-appengine.Sprite.kill_after_n_frames","text":"Kill the sprite in a delayed manner. Parameters: Name Type Description Default num int The number of frames after which the sprite will be killed. For example, given 20 FPS, setting 40 will kill the sprite after 2 seconds. required","title":"kill_after_n_frames()"},{"location":"api/#micropython-appengine.Sprite.set_layer","text":"Set the layer in which the sprite is located. A larger number means the sprite is in a more upper layer. Parameters: Name Type Description Default layer int The layer in which the sprite is located. required","title":"set_layer()"},{"location":"api/#micropython-appengine.Sprite.setup_animation","text":"Setup animation for the sprite. Parameters: Name Type Description Default start int The start index of the images for animation. required length int The length of the images for animation. required fpstep int Frames per step for animation speed. required","title":"setup_animation()"},{"location":"api/#micropython-appengine.Sprite.update","text":"This method may implement the logic of the sprite. It is called before every frame. A passive sprite may not override it.","title":"update()"},{"location":"hidden/hidden/","text":"A hidden page # This is an example of a hidden page. This page is not listed in the navigation column.","title":"A hidden page"},{"location":"hidden/hidden/#a-hidden-page","text":"This is an example of a hidden page. This page is not listed in the navigation column.","title":"A hidden page"},{"location":"includes/abbreviations/","text":"","title":"Abbreviations"}]}